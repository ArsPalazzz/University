Трудоемкость(сложность) кода во многом определяется использованием циклов
Очевидно что трудоемкость возрастает, время падает, от количества используемых циклов
особенно на это влияет не количесвто циклов, а степень и вложенности(чем больше вложенность цикла, тем выше нотации биг О трудоемкость)
ПСЕВДОАЛГОРИТМ ЭТО ХОРОШО(ДЛЯ РЕФЕРАТОВ)
т.к. высокая степень влжености требует больше времени, нужны разновидности циклов
1) кантинью - завершение итерации
2)брейк - завершение цикла
выражение проверки истинности - ложно(нормальное завершния цикло)
досрочное - второе исп. брейк(усл. истинно)


which ((ch = getchar()) != EOF)
{
if(ch == '\n')
break;
outchar(ch);
}

11.3Оператор continue
break - завершает цикл, continue - авершает итерацию и переходит к следующей

11.4 одновр исп break  и continue позволяет 
while((c=getchar())!=EOF)
{
if(isascii(c)==0)
{
cout << "Not an ASCII character; "; //Не ASCII-символ
break;
}
if(ispunct(c) || isspace(c)) {
putchar(NEWLINE);
continue;
}
if(isprint(c)==0) {
c= getchar();
continue;
}
putchar(c);
}


#define NEWLINE '\n'

11.5 оператор goto
оператор без условия кода(осущ переход всегда)
goto part2
part2: printf("Уточненный анализ :\n")

оператор oto является наследование фортрана
использование goto
кто исп goto в коде, тот не умеет программировать(т.к. у него есть много альтернатив и затрачивается много ресурсов(наверное))


if(size > 12) - с goto
goto a;
goto b;
a : cost = cost * 1.05;
flag = 2;
b: bill = cost * flag;



if(size > 12) - без goto
{
cost = cost * 1.05;
flag = 2;
}
bill = cost * flag;


if(size > 14)
goto a;
sheds = 2;
goto b;
a: sheds = 3;
b: help = 2*sheds;

if(ibex>14);
sheds=3;
else
sheds=2;
help=2*sheds;



if(ibex>14)
sheds=3;
else
sheds=2;
help=2*sheds;



readin:scanf(" %d", &scope);
if(scope<0)
goto stage2;
большое количество операторов;
goto readin;
stage2: дополнительная чепуха;




readin: scanf(" %d", &scope);
if(scope<0)
goto stage2;
большое количество операторов;
goto readin;
stage2: дополнительная чепуха;


scanf("%d", &scope);
while(scope >=0)
{
большое количество операторов;
scanf("%d", &scope);
дополнительная чепуха;

ПРОПУСК CONTINUE....(ДЛЯ ЦИКЛА) И BREAK


ЕД. МЕСТО ОПРАВДАННОГО ИСПОЛЬЗОВАНИЯ GOTO:

while(funct > 0)
{
for(i=1; i<100; i++)
{
for(j=1;j<=50;j++)
{
большое число операторов;
if(болтшая обишка)
goto help;
операторы;
}
еще операторы;
}
и еще;
}
и еще;
help: устранение ошибки;


ОПЕРАТОР EXIT
завершение работы ф-ции выполн. с помошбю оператора backend
оператор обязан быть во всех видах ф-ций за иск. 


exit также завершает работу, но не функции а программы
причем эксит возвр значение, кот. может проанализировано операционной системы
в кач возравщ значение чаще всего фигурируют 2
1)успешное завершнение exit_success
2) exit_failure

возвзращ знач имеет код ошибки
возращ знач может быть любое целое число или идентификатор из таблицы ошибков


разновидностью ф-ции exit это atexit
ее отличие - передает управление выполнение коду внутри программы после ее завершнения

void atexit_fn1(void);
void atexit_fn2(void);
main()
{
atexit(atexit_fn1);
atexit(atexit_fn2);
printf("Atexit program entered.\n"); //вход в программу Atexit. 
printf("Arexit program exited.\n\n"); //выход из программы Atexit
printf(">>>>>>>>>><<<<<<<<,\n\n");
}


void atexit_fn1(void)
{
printf("atexit_fn1 entered.\n"); //вход в ф-цию atexit_fn1
}
void atexit_fn2(void)
{
printf("ate




12. Массивы
в СИ предоставляют возмонотсь манипулированть многими данными с одним именем
массив - именованная область памяти содержашая однотипные значения
12.1 
понятие массив
массив описывается обшим выражением type Name[Max],
идентификатор max имеет двойное значение:
номер индекса массива(номерация индекса начинается с 0)
опеределяет количество элементов при написании



float debts[20];

обращаться к номерам массива можно по номеру индекса или с помогбю указателя
компилятор обращается к элементу массива только вторым способом

оба способа являются равноценными по скорости обращения данных

int sum, average;
for(i=0; sum=0; i<=9;i++)
sum +=a[i];
average=sum/10;

