13.1.5.1
Все сказанное для одномерного массива применимо для указателей
первый элемент 0.0

указатели на указатели
гибкость языка во многом .. возможность исп косвенным способом адресации(когда манипуляции выполняются не над адресом переменном, а надо указателем на указатель)
индекс косвенности не ограничен
ЗАМЕЧАНИЯ: исп косвенного способа адресации мощнейшее средство управления памяти
для поднятия индекса указателя исп не один, а требуемое количество описателей
указатель имеет 2 типа: данные и тип указателя


int ivalue = 10;
int *pi;
int*ppi.
int**pppi;
pi=&ivalue;
ppi=&pi;
pppi=&ppi;

для доступа к данным, для многоуровнего индекса, требуется выполнить операцию столько раз, на каком уровне индекс(для 3 уровневой нужно выполнить 3 итерации разыменования и т.д.)
указатель может исп для работы со строкой двояко
1)быть константным(адрес не изм)
2)быть переменной


char *psz = "File not ready";


char *psz;
psz = "File not ready";

ТИПОВЫЕ ОШИБКИ





#define PR(X) printf(" X=%u, *X = %d, &X = %u\n",X,*X,&X)
int urn[] = {100,200,300};
main()

{int*ptr1, *ptr2;

ptr1 = urn;
ptr2 = &urn[2];
PR(ptr1);
ptr1++;
PR(ptr1);
PR(ptr2);
++ptr2;
PR(ptr2);
printf("ptr2-ptr1 = %u\n", ptr2 - ptr1);
}
(define - нужен для определения констант)

PR(X) - обозначение макросса, принтф и т.д. - сам макросс


ЗАМЕЧАНИЕ
строки в макросе не видоизменяются
