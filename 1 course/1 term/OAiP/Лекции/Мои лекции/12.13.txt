При проектировании программы возможные варианты управления оперативной памяти
1)Выделяется памяти больше чем требуется
2)Выделяется памяти ровно столько , сколько требует програмаа
3)выделяется памяти минимальное количество
третий вариант наиболее продуктивный
в случае недостатка памяти пользователю доступна область куча(хип) , ее расположение не выходит за рамки памяти, выделенной компьютером
теънология выдления памяти сводится к:
1)запрос на выделение памяти
2)использование в процессе вычисления
3)возврат выделенной памяти под управление операционной системе

выделение памяти может быть выполнено несколькими способами
1)malloc, calloc, free (для си)
2)new (c++)

оператор нбъ обладает особенностью(схема выделения памяти отличается от маллок и калллок)
1)нью удобное для выделения памяти объектам

особождение памяти осущ методами free и delete

free освобождает памяти из маллок и каллок
дэлит для нью

пример



int pint = (int*)malloc(3*sizeof(int));
//необходимо сочетать преобразование типа если 



void free(void *block);
для выделения памяти нужны библиотеки 

если не возвращается NULL , то все хорошо



int main(void)
{
int* pRegion;
//videlenie pamyati
if((pRegion=(int*)malloc(10*sizeof(int)))==NULL)
{
cout << "Nedostatochno pamyati\n";
return 1;
}
for(int i=0; i< 10;i++)
*(pRegion+1) = i;
for(int i=0; i< 10;i++)
{
cout << (*pRegion) << "\n";
pRegion++;
}
free(pRegion);
return 0;
}





выделение памяти с помошбю нбю
new является перегружаемым(одно из свойств ооп)

тип_обекта *имя = new тип_объекта;
delete имя;

для выделени памяти массиву будет исп синтаксис

тип объекта *имя = new тип_объекта[число];


int main()
 {
int* ptr;
ptr = new int[100];
for(int i = 0; i < 100; i++)
*(ptr+i) = 100 - i;
for(int i = 0; i < 100; i++)
cout << *(ptr+i) << " ";
delete[] ptr;
return 0;
}


12.13.2
функиця memset()

ячейки динамечской выделенной памяти осхраниют значениеЮ которое будет до этого
гарантированно память обнуляется(значение памяти) только для статического класса памяти(статик)

...эта проблема по разному решается в разных версия вижуал студио
для заполнения памяти одним значением исп фция memset

причем присв. знач явл. тип данных чар

void *memset(void *dest, int cchar, size_t count);


очевидно что выделение памяти может исп не только для скалярных значений, не только для одном массива, но и для многомерного массива


13.


нужно знать назначения указателей

одно из основных достоинств си возмонжость урпалять не только данными, но и памятью, это позволяет манипулировать данными на низком уровне
2) использовать разные способы адресации данных
3) использовать косвенную адресацию
4) манипулировать данными без логических имен(без имен идентификатора)
это приближает си к ассемблеру(т.к. ассемблер работает с языками высокого уровня)
доступ к памяти си осущ. с помонб. указателей 
адрес является данным для кода(переменная кот содержит адрес)
это позволяет манипулироть с адресами , а не только с данными


13.1


общий синтаксис
type*PointName;
тайп - тип данных, кот соответсвует указатлей
поинтнэйм- имя идентификатора(указателя)

ПРИ РАБОТЕ С УКАЗАТЕЛЯМИ НУЖНО УЧИТЫВАТЬ:
1)С КАКИМ ТИПОМ ДАННЫХ МАНИПУЛИРУЕТ УКАЗАТЕЛЬ
2)САМ УКАЗАТЕЛЬ ИМЕЕТ СОБСТВЕННЫЙ ТИП(ТИП ДАННЫХ УКАЗАТЕЛЯ И ТИП ДАННЫХ ИМЕНИ)
В КАЧЕСТВЕ ТИПА УКАЗАТЕЛЯ ЧАЩЕ ВСЕГО ВЫСТУПАЕТ ВОИД(ЛЕГКОСТЬЮ)

ДЛЯ ОПРЕДЕЛЕНИЯ УКАЗАТЕЛЯ ИСП ОПЕРАЦИЯ АМПЕРСАНД

pimemorycell_address = &imemorycell_contents;

операция разыменования:

pimemorycell_address = &imemorycell_contents;
*pimemorycell_address = 20; 


//след. строчка явл аналогом предыдущей операции

imemorycell_contents = 20; (тут исп имя, а не адрес)



тип_объекта* идентификатор;

адрес может быть константой(может не изменяться)

char Symbol = 'Y';
char *pSymbol = &Symbol;
long Capital = 304L;
long* pLong;
pLong = &Capital;

не допускается исп один и тот же указатель для множества типов

13.1.2
пример использования указателя для обмена данными двух переменных

int iresult_a = 15, iresult_b = 37, itemporary;
int *piresult;

piresult = &iresult_a;
itemporary = *piresult;
*piresult = iresult_b;
iresult_b = itemporary;


13.1.3 Инициализация указателей

int iresult;
int* piresult = &iresult;

13.1.4 Неправильное исп операции определения адреса

//nelza isp with const
pivariable = &48;
//nelza isp v virazh s arifm operaziyami
int iresult = 5;
pivariable = &(iresult+15);
//nelza isp with registr peremen
register regirster1;
pivariavle=&register1;

13.1.5 указатели на массивы
имя массива определяет константный адрес который хранит данные
поэтому исп. смещение можно обратится к любому элементу, не используя индекс

#define IMAXREADINGS 20
float ftemperatures[IMAXREADINGS];
float *pftemp;

pftemp = ftemperatures;

pftemp = &ftemperatures[0];

ftemperatures = pftemp;
&ftemperatures[0] = pftemp;

недопустимо присв константе значение адреса

указателем многомерного массива

